//-----------------------------------------------------------------------------
// <auto-generated>
//     This file was generated by the C# SDK Code Generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------------


using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine.Scripting;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using Unity.Services.Economy.Internal.Http;


using System.ComponentModel;
using System.IO;
using Newtonsoft.Json.Linq;

namespace Unity.Services.Economy.Internal.Models
{
    /// <summary>
    /// PlayerConfigurationResponseResultsOneOf model
    /// </summary>
    [Preserve]
    [JsonConverter(typeof(PlayerConfigurationResponseResultsOneOfJsonConverter))]
    [DataContract(Name = "PlayerConfigurationResponseResultsOneOf")]
    internal class PlayerConfigurationResponseResultsOneOf : IOneOf
    {
        /// <summary> Value </summary>
        public object Value { get; }
        /// <summary> Type </summary>
        public Type Type { get; }
        private const string DiscriminatorKey = "type";

        /// <summary>PlayerConfigurationResponseResultsOneOf Constructor</summary>
        /// <param name="value">The value as an object for PlayerConfigurationResponseResultsOneOf</param>
        /// <param name="type">The type for PlayerConfigurationResponseResultsOneOf</param>
        public PlayerConfigurationResponseResultsOneOf(object value, Type type)
        {
            this.Value = value;
            this.Type = type;
        }

        private static Dictionary<string, Type> TypeLookup = new Dictionary<string, Type>()
        {
            { "CURRENCY", typeof(CurrencyResource) },
            { "INVENTORY_ITEM", typeof(InventoryItemResource) },
            { "MONEY_PURCHASE", typeof(RealMoneyPurchaseResource) },
            { "VIRTUAL_PURCHASE", typeof(VirtualPurchaseResource) },
            { "CurrencyResource", typeof(CurrencyResource) }, 
            { "InventoryItemResource", typeof(InventoryItemResource) }, 
            { "RealMoneyPurchaseResource", typeof(RealMoneyPurchaseResource) }, 
            { "VirtualPurchaseResource", typeof(VirtualPurchaseResource) }
            
        };
        private static List<Type> PossibleTypes = new List<Type>(){ typeof(CurrencyResource) , typeof(InventoryItemResource) , typeof(RealMoneyPurchaseResource) , typeof(VirtualPurchaseResource)  };

        private static Type GetConcreteType(string type)
        {
            if (!TypeLookup.ContainsKey(type))
            {
                string possibleValues = String.Join(", ", TypeLookup.Keys.ToList());
                throw new ArgumentException("Failed to lookup discriminator value for " + type + ". Possible values: " + possibleValues);
            }
            else
            {
                return TypeLookup[type];
            }
        }

        /// <summary>
        /// Converts the JSON string into an instance of PlayerConfigurationResponseResultsOneOf
        /// </summary>
        /// <param name="jsonString">JSON string</param>
        /// <returns>An instance of PlayerConfigurationResponseResultsOneOf</returns>
        public static PlayerConfigurationResponseResultsOneOf FromJson(string jsonString)
        {
            if (jsonString == null)
            {
                return null;
            }

            if (String.IsNullOrEmpty(DiscriminatorKey))
            {
                return DeserializeIntoActualObject(jsonString);
            }
            else
            {
                var parsedJson = JObject.Parse(jsonString);
                if (!parsedJson.ContainsKey(DiscriminatorKey))
                {
                    throw new MissingFieldException("PlayerConfigurationResponseResultsOneOf", DiscriminatorKey);
                }
                string discriminatorValue = parsedJson[DiscriminatorKey].ToString();

                return DeserializeIntoActualObject(discriminatorValue, jsonString);
            }
        }

        private static PlayerConfigurationResponseResultsOneOf DeserializeIntoActualObject(string discriminatorValue, string jsonString)
        {
            object actualObject = null;
            Type concreteType = GetConcreteType(discriminatorValue);

            if (concreteType == null)
            {
                string possibleValues = String.Join(", ", TypeLookup.Keys.ToList());
                throw new InvalidDataException("Failed to lookup discriminator value for " + discriminatorValue + ". Possible values: " + possibleValues);
            }

            actualObject = JsonConvert.DeserializeObject(jsonString, concreteType);

            return new PlayerConfigurationResponseResultsOneOf(actualObject, concreteType);
        }

        private static PlayerConfigurationResponseResultsOneOf DeserializeIntoActualObject(string jsonString)
        {
            var results = new List<(object ActualObject, Type ActualType)>();
            foreach (Type t in PossibleTypes)
            {
                try
                {
                    var deserializedClass = JsonConvert.DeserializeObject(jsonString, t);
                    results.Add((deserializedClass, t));
                }
                catch (Exception)
                {
                    // Do nothing
                }
            }

            if (results.Count() == 0)
            {
                string message = $"Could not deserialize into any of possible types. Possible types are: {String.Join(", ", PossibleTypes)}";
                throw new ResponseDeserializationException(message);
            }

            if (results.Count() > 1)
            {
                string message = $"Could not deserialize; type is ambiguous. Possible types are: {String.Join(", ", results.Select(p => p.ActualType))}";
                throw new ResponseDeserializationException(message);
            }

            return new PlayerConfigurationResponseResultsOneOf(results.First().ActualObject, results.First().ActualType);
        }
    }

    /// <summary>
    /// Custom JSON converter for PlayerConfigurationResponseResultsOneOf to allow for deserialization into OneOf type
    /// </summary>
    [Preserve]
    internal class PlayerConfigurationResponseResultsOneOfJsonConverter : JsonConverter
    {
        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            throw new NotImplementedException();
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            if(reader.TokenType != JsonToken.Null)
            {
                return PlayerConfigurationResponseResultsOneOf.FromJson(JObject.Load(reader).ToString(Formatting.None));
            }
            return null;
        }

        public override bool CanConvert(Type objectType)
        {
            throw new NotImplementedException();
        }
    }
}


