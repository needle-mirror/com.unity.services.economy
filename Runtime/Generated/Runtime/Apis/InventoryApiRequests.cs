//-----------------------------------------------------------------------------
// <auto-generated>
//     This file was generated by the C# SDK Code Generator.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//-----------------------------------------------------------------------------


using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using Newtonsoft.Json;
using UnityEngine;
using UnityEngine.Networking;
using UnityEngine.Scripting;
using Unity.Services.Economy.Internal.Models;
using Unity.Services.Economy.Internal.Scheduler;
using Unity.Services.Authentication.Internal;

namespace Unity.Services.Economy.Internal.Inventory
{
    internal static class JsonSerialization
    {
        public static byte[] Serialize<T>(T obj)
        {
            return Encoding.UTF8.GetBytes(SerializeToString(obj));
        }

        public static string SerializeToString<T>(T obj)
        {
            return JsonConvert.SerializeObject(obj, new JsonSerializerSettings{ReferenceLoopHandling = Newtonsoft.Json.ReferenceLoopHandling.Ignore});
        }
    }

    /// <summary>
    /// InventoryApiBaseRequest class
    /// </summary>
    [Preserve]
    internal class InventoryApiBaseRequest
    {
        /// <summary>
        /// Helper function to add a provided key and value to the provided
        /// query params and to escape the values correctly if it is a URL.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="key">The key to be added.</param>
        /// <param name="value">The value to be added.</param>
        /// <returns>Returns a `List/<string/>` with the `key` and `value` added to the provided `queryParams`.</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams(List<string> queryParams, string key, string value)
        {
            key = UnityWebRequest.EscapeURL(key);
            value = UnityWebRequest.EscapeURL(value);
            queryParams.Add($"{key}={value}");

            return queryParams;
        }

        /// <summary>
        /// Helper function to add a provided key and list of values to the
        /// provided query params and to escape the values correctly if it is a
        /// URL.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="key">The key to be added.</param>
        /// <param name="values">List of values to be added.</param>
        /// <param name="style">string for defining the style, currently unused.</param>
        /// <param name="explode">True if query params should be escaped and added separately.</param>
        /// <returns>Returns a `List/<string/>`</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams(List<string> queryParams, string key, List<string> values, string style, bool explode)
        {
            if (explode)
            {
                foreach(var value in values)
                {
                    string escapedValue = UnityWebRequest.EscapeURL(value);
                    queryParams.Add($"{UnityWebRequest.EscapeURL(key)}={escapedValue}");
                }
            }
            else
            {
                string paramString = $"{UnityWebRequest.EscapeURL(key)}=";
                foreach(var value in values)
                {
                    paramString += UnityWebRequest.EscapeURL(value) + ",";
                }
                paramString = paramString.Remove(paramString.Length - 1);
                queryParams.Add(paramString);
            }

            return queryParams;
        }

        /// <summary>
        /// Helper function to add a provided map of keys and values, representing a model, to the
        /// provided query params.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="modelVars">A `Dictionary` representing the vars of the model</param>
        /// <returns>Returns a `List/<string/>`</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams(List<string> queryParams, Dictionary<string, string> modelVars)
        {
            foreach(var key in modelVars.Keys)
            {
                string escapedValue = UnityWebRequest.EscapeURL(modelVars[key]);
                queryParams.Add($"{UnityWebRequest.EscapeURL(key)}={escapedValue}");
            }

            return queryParams;
        }

        /// <summary>
        /// Helper function to add a provided key and value to the provided
        /// query params and to escape the values correctly if it is a URL.
        /// </summary>
        /// <param name="queryParams">A `List/<string/>` of the query parameters.</param>
        /// <param name="key">The key to be added.</param>
        /// <typeparam name="T">The type of the value to be added.</typeparam>
        /// <param name="value">The value to be added.</param>
        /// <returns>Returns a `List/<string/>`</returns>
        [Preserve]
        public List<string> AddParamsToQueryParams<T>(List<string> queryParams, string key, T value)
        {
            if (queryParams == null)
            {
                queryParams = new List<string>();
            }

            key = UnityWebRequest.EscapeURL(key);
            string valueString = UnityWebRequest.EscapeURL(value.ToString());
            queryParams.Add($"{key}={valueString}");
            return queryParams;
        }

        /// <summary>
        /// Constructs a string representing an array path parameter.
        /// </summary>
        /// <param name="pathParam">The list of values to convert to string.</param>
        /// <returns>String representing the param.</returns>
        [Preserve]
        public string GetPathParamString(List<string> pathParam)
        {
            string paramString = "";
            foreach(var value in pathParam)
            {
                paramString += UnityWebRequest.EscapeURL(value) + ",";
            }
            paramString = paramString.Remove(paramString.Length - 1);
            return paramString;
        }

        /// <summary>
        /// Constructs the body of the request based on IO stream.
        /// </summary>
        /// <param name="stream">The IO stream to use.</param>
        /// <returns>Byte array representing the body.</returns>
        public byte[] ConstructBody(System.IO.Stream stream)
        {
            if (stream != null)
            {
                using (System.IO.MemoryStream ms = new System.IO.MemoryStream())
                {
                    stream.CopyTo(ms);
                    return ms.ToArray();
                }
            }
            return null;
        }

        /// <summary>
        /// Construct the request body based on string value.
        /// </summary>
        /// <param name="s">The input body.</param>
        /// <returns>Byte array representing the body.</returns>
        public byte[] ConstructBody(string s)
        {
            return System.Text.Encoding.UTF8.GetBytes(s);
        }

        /// <summary>
        /// Construct request body based on generic object.
        /// </summary>
        /// <param name="o">The object to use.</param>
        /// <returns>Byte array representing the body.</returns>
        public byte[] ConstructBody(object o)
        {
            return JsonSerialization.Serialize(o);
        }

        /// <summary>
        /// Generate an accept header.
        /// </summary>
        /// <param name="accepts">list of accepts objects.</param>
        /// <returns>The generated accept header.</returns>
        public string GenerateAcceptHeader(string[] accepts)
        {
            if (accepts.Length == 0)
            {
                return null;
            }
            for (int i = 0; i < accepts.Length; ++i)
            {
                if (string.Equals(accepts[i], "application/json", System.StringComparison.OrdinalIgnoreCase))
                {
                    return "application/json";
                }
            }
            return string.Join(", ", accepts);
        }

        private static readonly Regex JsonRegex = new Regex(@"application\/json(;\s)?((charset=utf8|q=[0-1]\.\d)(\s)?)*");

        /// <summary>
        /// Generate Content Type Header.
        /// </summary>
        /// <param name="contentTypes">The content types.</param>
        /// <returns>The Content Type Header.</returns>
        public string GenerateContentTypeHeader(string[] contentTypes)
        {
            if (contentTypes.Length == 0)
            {
                return null;
            }

            for(int i = 0; i < contentTypes.Length; ++i)
            {
                if (!string.IsNullOrWhiteSpace(contentTypes[i]) && JsonRegex.IsMatch(contentTypes[i]))
                {
                    return contentTypes[i];
                }
            }
            return contentTypes[0];
        }

        /// <summary>
        /// Generate multipart form file section.
        /// </summary>
        /// <param name="paramName">The parameter name.</param>
        /// <param name="stream">The file stream to use.</param>
        /// <param name="contentType">The content type.</param>
        /// <returns>Returns a multipart form section.</returns>
        public IMultipartFormSection GenerateMultipartFormFileSection(string paramName, System.IO.FileStream stream, string contentType)
        {
            return new MultipartFormFileSection(paramName, ConstructBody(stream), GetFileName(stream.Name), contentType);
        }

        /// <summary>
        /// Generate multipart form file section.
        /// </summary>
        /// <param name="paramName">The parameter name.</param>
        /// <param name="stream">The IO stream to use.</param>
        /// <param name="contentType">The content type.</param>
        /// <returns>Returns a multipart form section.</returns>
        public IMultipartFormSection GenerateMultipartFormFileSection(string paramName, System.IO.Stream stream, string contentType)
        {
            return new MultipartFormFileSection(paramName, ConstructBody(stream), Guid.NewGuid().ToString(), contentType);
        }

        private string GetFileName(string filePath)
        {
            return System.IO.Path.GetFileName(filePath);
        }
    }

    /// <summary>
    /// AddInventoryItemRequest
    /// Add inventory item
    /// </summary>
    [Preserve]
    internal class AddInventoryItemRequest : InventoryApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }
        /// <summary>Accessor for playerId </summary>
        [Preserve]
        public string PlayerId { get; }
        /// <summary>Accessor for addInventoryRequest </summary>
        [Preserve]
        public Unity.Services.Economy.Internal.Models.AddInventoryRequest AddInventoryRequest { get; }
        /// <summary>Accessor for configAssignmentHash </summary>
        [Preserve]
        public string ConfigAssignmentHash { get; }
        /// <summary>Accessor for unityInstallationId </summary>
        [Preserve]
        public string UnityInstallationId { get; }
        /// <summary>Accessor for analyticsUserId </summary>
        [Preserve]
        public string AnalyticsUserId { get; }
        string PathAndQueryParams;

        /// <summary>
        /// AddInventoryItem Request Object.
        /// Add inventory item
        /// </summary>
        /// <param name="projectId">ID of the project.</param>
        /// <param name="playerId">ID of the player.</param>
        /// <param name="addInventoryRequest">AddInventoryRequest param</param>
        /// <param name="configAssignmentHash">Configuration assignment hash that should be used when processing this request.</param>
        /// <param name="unityInstallationId">Unique identifier that identifies an installation on the client’s device. The same player can have different installationIds if they have the game installed on different devices. It is available to all Unity packages that integrate with the Services SDK Core package.</param>
        /// <param name="analyticsUserId">A unique string that identifies the player and is consistent across their subsequent play sessions for analytics purposes. It is the primary user identifier and it comes from the Core package.</param>
        [Preserve]
        public AddInventoryItemRequest(string projectId, string playerId, Unity.Services.Economy.Internal.Models.AddInventoryRequest addInventoryRequest, string configAssignmentHash = default(string), string unityInstallationId = default(string), string analyticsUserId = default(string))
        {
            ProjectId = projectId;

            PlayerId = playerId;

            AddInventoryRequest = addInventoryRequest;
            ConfigAssignmentHash = configAssignmentHash;
            UnityInstallationId = unityInstallationId;
            AnalyticsUserId = analyticsUserId;
            PathAndQueryParams = $"/v2/projects/{projectId}/players/{playerId}/inventory";

            List<string> queryParams = new List<string>();

            if(!string.IsNullOrEmpty(ConfigAssignmentHash))
            {
                queryParams = AddParamsToQueryParams(queryParams, "configAssignmentHash", ConfigAssignmentHash);
            }
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return ConstructBody(AddInventoryRequest);
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "POST";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(UnityInstallationId))
            {
                headers.Add("Unity-installation-id", UnityInstallationId);
            }
            if(!string.IsNullOrEmpty(AnalyticsUserId))
            {
                headers.Add("Analytics-user-id", AnalyticsUserId);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// DeleteInventoryItemRequest
    /// Delete player&#39;s inventory item
    /// </summary>
    [Preserve]
    internal class DeleteInventoryItemRequest : InventoryApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }
        /// <summary>Accessor for playerId </summary>
        [Preserve]
        public string PlayerId { get; }
        /// <summary>Accessor for playersInventoryItemId </summary>
        [Preserve]
        public string PlayersInventoryItemId { get; }
        /// <summary>Accessor for configAssignmentHash </summary>
        [Preserve]
        public string ConfigAssignmentHash { get; }
        /// <summary>Accessor for unityInstallationId </summary>
        [Preserve]
        public string UnityInstallationId { get; }
        /// <summary>Accessor for analyticsUserId </summary>
        [Preserve]
        public string AnalyticsUserId { get; }
        /// <summary>Accessor for writeLock </summary>
        [Preserve]
        public string WriteLock { get; }
        /// <summary>Accessor for inventoryDeleteRequest </summary>
        [Preserve]
        public Unity.Services.Economy.Internal.Models.InventoryDeleteRequest InventoryDeleteRequest { get; }
        string PathAndQueryParams;

        /// <summary>
        /// DeleteInventoryItem Request Object.
        /// Delete player&#39;s inventory item
        /// </summary>
        /// <param name="projectId">ID of the project.</param>
        /// <param name="playerId">ID of the player.</param>
        /// <param name="playersInventoryItemId">The `playersInventoryItemId` of the item to be updated.</param>
        /// <param name="configAssignmentHash">Configuration assignment hash that should be used when processing this request.</param>
        /// <param name="unityInstallationId">Unique identifier that identifies an installation on the client’s device. The same player can have different installationIds if they have the game installed on different devices. It is available to all Unity packages that integrate with the Services SDK Core package.</param>
        /// <param name="analyticsUserId">A unique string that identifies the player and is consistent across their subsequent play sessions for analytics purposes. It is the primary user identifier and it comes from the Core package.</param>
        /// <param name="writeLock">The writelock for a database entry.</param>
        /// <param name="inventoryDeleteRequest">InventoryDeleteRequest param</param>
        [Preserve]
        public DeleteInventoryItemRequest(string projectId, string playerId, string playersInventoryItemId, string configAssignmentHash = default(string), string unityInstallationId = default(string), string analyticsUserId = default(string), string writeLock = default(string), Unity.Services.Economy.Internal.Models.InventoryDeleteRequest inventoryDeleteRequest = default(Unity.Services.Economy.Internal.Models.InventoryDeleteRequest))
        {
            ProjectId = projectId;

            PlayerId = playerId;

            PlayersInventoryItemId = playersInventoryItemId;

            ConfigAssignmentHash = configAssignmentHash;
            UnityInstallationId = unityInstallationId;
            AnalyticsUserId = analyticsUserId;
            WriteLock = writeLock;
            InventoryDeleteRequest = inventoryDeleteRequest;
            PathAndQueryParams = $"/v2/projects/{projectId}/players/{playerId}/inventory/{playersInventoryItemId}";

            List<string> queryParams = new List<string>();

            if(!string.IsNullOrEmpty(ConfigAssignmentHash))
            {
                queryParams = AddParamsToQueryParams(queryParams, "configAssignmentHash", ConfigAssignmentHash);
            }
            if(!string.IsNullOrEmpty(WriteLock))
            {
                queryParams = AddParamsToQueryParams(queryParams, "writeLock", WriteLock);
            }
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            if(InventoryDeleteRequest != null)
            {
                return ConstructBody(InventoryDeleteRequest);
            }
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "DELETE";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(UnityInstallationId))
            {
                headers.Add("Unity-installation-id", UnityInstallationId);
            }
            if(!string.IsNullOrEmpty(AnalyticsUserId))
            {
                headers.Add("Analytics-user-id", AnalyticsUserId);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// GetPlayerInventoryRequest
    /// List player inventory
    /// </summary>
    [Preserve]
    internal class GetPlayerInventoryRequest : InventoryApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }
        /// <summary>Accessor for playerId </summary>
        [Preserve]
        public string PlayerId { get; }
        /// <summary>Accessor for configAssignmentHash </summary>
        [Preserve]
        public string ConfigAssignmentHash { get; }
        /// <summary>Accessor for unityInstallationId </summary>
        [Preserve]
        public string UnityInstallationId { get; }
        /// <summary>Accessor for analyticsUserId </summary>
        [Preserve]
        public string AnalyticsUserId { get; }
        /// <summary>Accessor for after </summary>
        [Preserve]
        public string After { get; }
        /// <summary>Accessor for limit </summary>
        [Preserve]
        public int? Limit { get; }
        /// <summary>Accessor for playersInventoryItemIds </summary>
        [Preserve]
        public List<string> PlayersInventoryItemIds { get; }
        /// <summary>Accessor for inventoryItemIds </summary>
        [Preserve]
        public List<string> InventoryItemIds { get; }
        string PathAndQueryParams;

        /// <summary>
        /// GetPlayerInventory Request Object.
        /// List player inventory
        /// </summary>
        /// <param name="projectId">ID of the project.</param>
        /// <param name="playerId">ID of the player.</param>
        /// <param name="configAssignmentHash">Configuration assignment hash that should be used when processing this request.</param>
        /// <param name="unityInstallationId">Unique identifier that identifies an installation on the client’s device. The same player can have different installationIds if they have the game installed on different devices. It is available to all Unity packages that integrate with the Services SDK Core package.</param>
        /// <param name="analyticsUserId">A unique string that identifies the player and is consistent across their subsequent play sessions for analytics purposes. It is the primary user identifier and it comes from the Core package.</param>
        /// <param name="after">The `playersInventoryItemId` after which to retrieve the next page of balances.</param>
        /// <param name="limit">Number of items to be returned. Defaults to 20.</param>
        /// <param name="playersInventoryItemIds">List of `playersInventoryItemIds` in array notation, for example, `playersInventoryItemIds[]=ID1&playersInventoryItemIds[]=ID2`.</param>
        /// <param name="inventoryItemIds">List of inventory item IDs in array notation, for example, `inventoryItemIds[]=ID1&inventoryItemIds[]=ID2`.</param>
        [Preserve]
        public GetPlayerInventoryRequest(string projectId, string playerId, string configAssignmentHash = default(string), string unityInstallationId = default(string), string analyticsUserId = default(string), string after = default(string), int? limit = default(int?), List<string> playersInventoryItemIds = default(List<string>), List<string> inventoryItemIds = default(List<string>))
        {
            ProjectId = projectId;

            PlayerId = playerId;

            ConfigAssignmentHash = configAssignmentHash;
            UnityInstallationId = unityInstallationId;
            AnalyticsUserId = analyticsUserId;
            After = after;
            Limit = limit;
            PlayersInventoryItemIds = playersInventoryItemIds;
            InventoryItemIds = inventoryItemIds;
            PathAndQueryParams = $"/v2/projects/{projectId}/players/{playerId}/inventory";

            List<string> queryParams = new List<string>();

            if(!string.IsNullOrEmpty(ConfigAssignmentHash))
            {
                queryParams = AddParamsToQueryParams(queryParams, "configAssignmentHash", ConfigAssignmentHash);
            }
            if(!string.IsNullOrEmpty(After))
            {
                queryParams = AddParamsToQueryParams(queryParams, "after", After);
            }
            var limitStringValue = Limit.ToString();
            queryParams = AddParamsToQueryParams(queryParams, "limit", limitStringValue);
            if(PlayersInventoryItemIds != null)
            {
                var playersInventoryItemIdsStringValues = PlayersInventoryItemIds.Select(v => v.ToString()).ToList();
                queryParams = AddParamsToQueryParams(queryParams, "playersInventoryItemIds", playersInventoryItemIdsStringValues, "form", true);
            }
            if(InventoryItemIds != null)
            {
                var inventoryItemIdsStringValues = InventoryItemIds.Select(v => v.ToString()).ToList();
                queryParams = AddParamsToQueryParams(queryParams, "inventoryItemIds", inventoryItemIdsStringValues, "form", true);
            }
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return null;
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "GET";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(UnityInstallationId))
            {
                headers.Add("Unity-installation-id", UnityInstallationId);
            }
            if(!string.IsNullOrEmpty(AnalyticsUserId))
            {
                headers.Add("Analytics-user-id", AnalyticsUserId);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
    /// <summary>
    /// UpdateInventoryItemRequest
    /// Update player&#39;s inventory item
    /// </summary>
    [Preserve]
    internal class UpdateInventoryItemRequest : InventoryApiBaseRequest
    {
        /// <summary>Accessor for projectId </summary>
        [Preserve]
        public string ProjectId { get; }
        /// <summary>Accessor for playerId </summary>
        [Preserve]
        public string PlayerId { get; }
        /// <summary>Accessor for playersInventoryItemId </summary>
        [Preserve]
        public string PlayersInventoryItemId { get; }
        /// <summary>Accessor for inventoryRequestUpdate </summary>
        [Preserve]
        public Unity.Services.Economy.Internal.Models.InventoryRequestUpdate InventoryRequestUpdate { get; }
        /// <summary>Accessor for configAssignmentHash </summary>
        [Preserve]
        public string ConfigAssignmentHash { get; }
        /// <summary>Accessor for unityInstallationId </summary>
        [Preserve]
        public string UnityInstallationId { get; }
        /// <summary>Accessor for analyticsUserId </summary>
        [Preserve]
        public string AnalyticsUserId { get; }
        string PathAndQueryParams;

        /// <summary>
        /// UpdateInventoryItem Request Object.
        /// Update player&#39;s inventory item
        /// </summary>
        /// <param name="projectId">ID of the project.</param>
        /// <param name="playerId">ID of the player.</param>
        /// <param name="playersInventoryItemId">The `playersInventoryItemId` of the item to be updated.</param>
        /// <param name="inventoryRequestUpdate">InventoryRequestUpdate param</param>
        /// <param name="configAssignmentHash">Configuration assignment hash that should be used when processing this request.</param>
        /// <param name="unityInstallationId">Unique identifier that identifies an installation on the client’s device. The same player can have different installationIds if they have the game installed on different devices. It is available to all Unity packages that integrate with the Services SDK Core package.</param>
        /// <param name="analyticsUserId">A unique string that identifies the player and is consistent across their subsequent play sessions for analytics purposes. It is the primary user identifier and it comes from the Core package.</param>
        [Preserve]
        public UpdateInventoryItemRequest(string projectId, string playerId, string playersInventoryItemId, Unity.Services.Economy.Internal.Models.InventoryRequestUpdate inventoryRequestUpdate, string configAssignmentHash = default(string), string unityInstallationId = default(string), string analyticsUserId = default(string))
        {
            ProjectId = projectId;

            PlayerId = playerId;

            PlayersInventoryItemId = playersInventoryItemId;

            InventoryRequestUpdate = inventoryRequestUpdate;
            ConfigAssignmentHash = configAssignmentHash;
            UnityInstallationId = unityInstallationId;
            AnalyticsUserId = analyticsUserId;
            PathAndQueryParams = $"/v2/projects/{projectId}/players/{playerId}/inventory/{playersInventoryItemId}";

            List<string> queryParams = new List<string>();

            if(!string.IsNullOrEmpty(ConfigAssignmentHash))
            {
                queryParams = AddParamsToQueryParams(queryParams, "configAssignmentHash", ConfigAssignmentHash);
            }
            if (queryParams.Count > 0)
            {
                PathAndQueryParams = $"{PathAndQueryParams}?{string.Join("&", queryParams)}";
            }
        }

        /// <summary>
        /// Helper function for constructing URL from request base path and
        /// query params.
        /// </summary>
        /// <param name="requestBasePath"></param>
        /// <returns></returns>
        public string ConstructUrl(string requestBasePath)
        {
            return requestBasePath + PathAndQueryParams;
        }

        /// <summary>
        /// Helper for constructing the request body.
        /// </summary>
        /// <returns>A list of IMultipartFormSection representing the request body.</returns>
        public byte[] ConstructBody()
        {
            return ConstructBody(InventoryRequestUpdate);
        }

        /// <summary>
        /// Helper function for constructing the headers.
        /// </summary>
        /// <param name="accessToken">The auth access token to use.</param>
        /// <param name="operationConfiguration">The operation configuration to use.</param>
        /// <returns>A dictionary representing the request headers.</returns>
        public Dictionary<string, string> ConstructHeaders(IAccessToken accessToken,
            Configuration operationConfiguration = null)
        {
            var headers = new Dictionary<string, string>();
            if(!string.IsNullOrEmpty(accessToken.AccessToken))
            {
                headers.Add("authorization", "Bearer " + accessToken.AccessToken);
            }

            // Analytics headers
            headers.Add("Unity-Client-Version", Application.unityVersion);
            headers.Add("Unity-Client-Mode", Scheduler.EngineStateHelper.IsPlaying ? "play" : "edit");

            string[] contentTypes = {
                "application/json"
            };

            string[] accepts = {
                "application/json",
                "application/problem+json"
            };

            var acceptHeader = GenerateAcceptHeader(accepts);
            if (!string.IsNullOrEmpty(acceptHeader))
            {
                headers.Add("Accept", acceptHeader);
            }
            var httpMethod = "PUT";
            var contentTypeHeader = GenerateContentTypeHeader(contentTypes);
            if (!string.IsNullOrEmpty(contentTypeHeader))
            {
                headers.Add("Content-Type", contentTypeHeader);
            }
            else if (httpMethod == "POST" || httpMethod == "PATCH")
            {
                headers.Add("Content-Type", "application/json");
            }

            if(!string.IsNullOrEmpty(UnityInstallationId))
            {
                headers.Add("Unity-installation-id", UnityInstallationId);
            }
            if(!string.IsNullOrEmpty(AnalyticsUserId))
            {
                headers.Add("Analytics-user-id", AnalyticsUserId);
            }

            // We also check if there are headers that are defined as part of
            // the request configuration.
            if (operationConfiguration != null && operationConfiguration.Headers != null)
            {
                foreach (var pair in operationConfiguration.Headers)
                {
                    headers[pair.Key] = pair.Value;
                }
            }

            return headers;
        }
    }
}
